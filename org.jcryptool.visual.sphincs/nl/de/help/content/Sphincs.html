<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
  
<head>	  
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>SPHINCS-Verfahren</title>
      
      <style>
      	#explanation {
      					float: left;
      					margin-left: 30px;
      					margin-right: 30px;
      					padding-bottom: 5px;
      				 }
      </style>
</head>

<body>
	<h1>SPHINCS</h1>
	
	<p>In diesem Plugin wird das Quantencomputer-resistente Signaturverfahren SPHINCS (in der zur Standardisierung eingereichten Variante SPHINCS-256) visualisiert. Die Sicherheit von SPHINCS beruht wie die bei MerkleTrees nur auf der Sicherheit der verwendeten Hashfunktionen und gehört deshalb zu den Hash-basierten Signaturfunktionen (HBS). Im Gegensatz zu MerkleTrees ist SPHINCS jedoch zustandslos, was für die Sicherheit der meisten Anwendungen ein großer Vorteil ist. Generell ist die Schlüssellänge bei QC-resistenten Signaturverfahren (auch Post-Quantum-Signaturverfahren genannt) deutlich größer als bei konventionellen Signaturverfahren.</p>  
	
	<p> Das Paper [1] fasst SPHINCS so zusammen: "Signatures are 41 kB, public keys are 1 kB, and private keys are 1 kB. The signature scheme is designed to provide long-term 2^128 security even against attackers equipped with quantum computers."</p>
	<p>SPHINCS steht kurz vor der Standardisierung durch die IETF ((( Oder nur sagen, dass beim NIST Post-Quantum Cryptography Standardization-Wettbewerb eingereicht?))) .<br>
	
	Die Abkürzung SPHINCS bedeutet: <b>S</b>tateless <b>P</b>ractical <b>H</b>ash-based <b>I</b>ncredibly <b>N</b>ice <b>C</b>ollision-resilient <b>S</b>ignatures.</p>  
	
	<p>Das Plugin enthält folgende Punkte:</p>
	<ul>
		<li><a href=#structure>Übersicht SPHINCS-Struktur</a></li>
		<li><a href=#keygen>Schl&uuml;sselgenerierung</a></li>
		<li><a href=#signature>Signatur-Erstellung</a></li>
		<li><a href=#verifikation">Verifizierung (Signatur-Prüfung)</a></li>
	</ul>

	<p>Die Abschnitte nach der Übersicht erläutern die 3 Operationen genauer. Danach wird die Bedienung des Plugin erläutert.</p>
	<br>

	
	<h2 id="structure">Übersicht SPHINCS-Struktur</h2>
	
	<p>SPHINCS generiert einen Baum aus mehreren Ebenen, die wiederum wie ein Baum aufgebaut sind. Diesen Gesamtbaum, der aus mehreren Baumstrukturen besteht, bezeichnet man als Hypertree oder SPHINCS-Struktur.</p>
	
	<p>In SPHINCS gibt es zwei Arten von Baumstrukturen, einmal WOTS+-Strukturen und einmal HORST-Strukturen. WOTS+ ist ein Einmal-Signaturverfahren, das in SPHINCS zum Signieren darunter liegender Strukturen verwendet wird. HORST ist ein Mehrfach-Signaturverfahren, das auf der untersten Ebene zum Signieren von Nachrichten verwendet wird.</p>
	
	<p>Eine SPHINCS-Struktur hat die Gesamth&oumlhe h=60. Jede Struktur, sowohl WOTS+ als auch HORST, besteht wiederum aus einem Baum mit der H&ouml;he (h/d=5), wobei d=12 die Anzahl der Ebenen ist.</p> 
	
	<p>Jeder Baum beinhaltet Schl&uuml;ssel, die an einer Adresse A liegen. (((Ist Adressen das richtige Wort?))) Adressen beschreiben die Position der Schl&uuml;ssel innerhalb der SPHINCS-Struktur.</p>
	
	<br>
	<h3>Visualisierung der SPHINCS-Struktur</h3>
	<img src=images/explanation.png alt="Legende" id=explanation />
	<br>
	<img src=images/structure.png alt="SPHINCS-Struktur" id=struktur />
	
	<p><b>Obenstehende Grafik zeigt einen HyperTree</b></p>
	<p>Dieser HyperTree ist (ausschnittsweise) im Reiter "SPHINCS-&Uuml;bersicht" zu sehen. ((( Bitte genauer, was zu sehen ist. )))</p>
	
	<br>
	<p>Eine WOTS+-Struktur besteht aus mehreren WOTS+-Public-Key-Knoten, die jeweils ein Schl&uuml;sselpaar ((( ein Schlüsselpaar oder nur einen Public-Key ? ))) ergeben, wie in der folgenden Grafik dargestellt:</p>
	<br>
	<img src=images/tree.jpg alt="WOTS+-Baum" id=baum />
	<p>Jede WOTS+-Struktur enthält 2^(h/d) = 2^5 = 32 Knoten. ((( Stimmt das so? ))) </p> 
	<br>
	
	
	<h2 id="keygen">Schl&uuml;sselgenerierung</h2>
	
	<p>Die Schl&uuml;sselerzeugung des SPHINCS-Verfahrens hat zum Ziel, den Wurzelknoten (Root) der gesamten SPHINCS-Struktur zu berechnen. Dieser wird dann als Public-Key verwendet.</p>
	
	<p>Bei der Generierung der Schl&uuml;ssel werden zuerst zwei Bitfolgen SK1 und SK2 generiert. SK1 wird pseudozuf&auml;llig generiert und dient als Seed für die pseudozuf&auml;llige Schl&uuml;sselgenerierung.  (((Ist SK2 die "Bitmaske", die im ersten Reiter in der Mitte dargestellt wird? Sind beide, SK1 und SK2 geheim zu halten? Werden beide pseudozufällig generiert?)))</p>
	
	<p>Ist die Operation der Schl&uuml;sselerzeugung abgeschlossen, hat man das WOTS+-Schl&uuml;sselpaar der Struktur auf der obersten Ebene der gesamten SPHINCS-Struktur.</p>
	
	<p>SK2 wird verwendet, um beim Signieren die Nachricht und somit auch den Hashwert der Nachricht zu randomisieren.</p>
	
	<p>Au&szlig;erdem werden Bitmasken Q (((Sollte hier nicht, weil es mehrere sind, Q_i stehen?))) für jede WOTS+-Struktur und jede HORST-Struktur generiert. Alle Q_i gehen ((( indirekt? ))) in den obersten Public-Key ein.</p>
	
	<p>Mit dem Seed und den Bitmasken wird dann der WOTS+-Public-Key der letzten (((Müsste das nicht der "oberste" heißen?))) WOTS+-Struktur berechnet.</p> 
	<p>Dieser Public-Key der WOTS+-Struktur wird mit den Bitmasken ge-XOR-ed und ergibt PK1, der als Hashwert im Public-Key ist.</p>
	<p>Der Wurzelknoten PK1 dieses Hashbaums ist ein Teil des SPHINCS-Public-Keys. ((( mir nicht klar ?)))</p>
	
	<p>Es gilt: SPHINCS-Private-Key = {SK1, SK2, Q}; SPHINCS-Public-Key = {PK1, Q}  (((mir nicht klar, welche Wurzel und welches Q ?  Reden wir hier von irgendeinem WOTS+-Knoten oder von einem HORST-Knoten oder vom obersten Knoten? )))</p>

	
	
	<br>
	<h2 id="signature">Signieren</h2>
	
	<p>Signiert wird eine Nachricht M mit einem SPHINCS-Private-Key {SK1, SK2, Q}.</p>
	
	<p>Dazu wird ein Hash D &uuml;ber M und Zufallswerte gebildet. Dieser Hash D wird dann signiert.</p>
	
	<p>Davor wird zunächst ein pseudozuf&auml;lliger Bitstrom R, bestehend aus zwei Teilwerten R1 und R2, gebildet. R2 wird ((( nochmal ))) aufgeteilt, um den Index  (((Ist Index das, was weiter oben als Adresse bezeichnet wurde?))) des zu verwendenden Schlüsselpaars anzugeben.</p>
	<p>Ein Teil des Indexes bestimmt die HORST-Struktur, der andere Teil bestimmt, welcher konkrete Schl&uuml;ssel innerhalb der HORST-Struktur verwendet werden soll, um zu signieren.</p>
	<p>Die HORST-Signatur wird aus einem Seed, dem Hash D und Bitmasken berechnet.</p>
	
	<p>Die SPHINCS-Signatur beinhaltet neben der HORST-Signatur, einem Index i, und Zufallsbits R1 auch noch eine WOTS+-Signatur und einen Authentifizierungspfad durch alle Ebenen.</p>
	
	<p>Der Index wir jedoch immer deterministisch ausgewählt, da bei einer Struktur dieser Größe kein zuverlässiger Zufall existiert, der die Indizes bestimmen k&ouml;nnte.((( Verstehe ich nicht? )))</p>
	
	<p>Die SPHINCS-Signatur besteht aus (i; R1; &sigma;H; &sigma;W_0; Auth_A0;...; &sigma;W_d−1; Auth_A_d−1) (&sigma;...Signatur, &sigma;H...HORST-Signatur). ((( Was genau sind die i und das sigma?)))</p>
	
	<br>
	 ((( Ist mit dem Summenzeichen am Ende der ff. Grafik eine Konkatenation oder eine wiederholte Anwendung gemeint?)))
	<img src=images/signierung_final.jpg alt=Signatur />
	  
	  
	  
	
	<br />
	<h2 id="verifikation">Verifikation</h2>
	
	<p>Zum Verifizieren werden ein SPHINCS-Public-Key (also der Wurzelknoten und ein Authentisierungspfad) und eine  vollst&auml;ndige  ((( Was ist mit vollständig gemeint? Gibt es auch unvollständige Signaturen? ))) SPHINCS-Signatur ben&ouml;tigt.</p> 
	
	<p>Zun&auml;chst wird ein Hash D &uuml;ber die Nachricht und den Zufallswert R1 ((( nicht über R2 ? ))), welcher in der Signatur enthalten ist, gebildet.</p>
	
	<p>Der Hash D und die im Public-Key enthaltenen Bitmasken Q werden dazu verwendet, um mithilfe der HORST-Verifikationsfunktion (D, &sigma;_HORST, Q_HORST) den HORST-Public-Key zu berechnen. Wenn die Verifizierung der HORST-Signatur, die in der SPHINCS-Signatur enthalten ist, fehlschl&auml;gt, dann ist auch die SPHINCS-Signatur ung&uuml;ltig.</p>
	
	<p>Mit der in der SPHINCS-Signatur enthaltenen WOTS+-Signatur wird der Public-Key der ersten WOTS+-Struktur berechnet.(((  Ist das so richtig? )))   Danach wird das Blatt der Struktur berechnet.</p>
	<p>Mit diesem Blatt ((( Welches Blatt ? ))) wird der Wurzelknoten (Root) der Struktur berechnet. Dieser Vorgang wird bis zur untersten (((Ist hier nicht die "oberste" Ebene, also die oberste Root gemeint?))) Ebene der SPHINCS-Struktur wiederholt.</p> 
	<p>Jedoch mit zwei Unterschieden:</p>
	<ol>
		<li>Der Wurzelknoten der vorherigen Struktur wird nun benötigt, um den Public-Key der dar&uuml;berliegenden Struktur zu berechnen.</li>
		<li>Die Blätter der Strukturen werden berechnet, indem die letzten j*(h/d) Bits von i ((( Was ist j? Was ist i? ))) abgeschnitten werden und davon die letzten (h/d) Bits verwendet werden.</li>
	</ol>
	
	<p>Diese zwei Besonderheiten werden aber erst ab der zweiten Ebene der SPHINCS-Struktur relevant.</p>
	<p>Nachdem der Authentifizierungspfad durchgerechnet wurde, ist das Resultat der Wurzelknoten der Ebene d-1 (((Ist d bekannt oder kann d eingegeben werden?))). Diesen vergleicht man dann mit dem SPHINCS-Public-Key.</p>
	<p>Sind die beiden Schlüssel identisch, gelingt die Verifikation, sind die beiden Schlüssel jedoch nicht identisch, so schl&auml;gt die Verifikation fehl.</p>
	
	<br />
	

	
	<h1>Bedienungsanleitung zu dieser Visualisierung</h1>
	 
	<p>In dieser Visualisierung wird das Signaturverfahren SPHINCS erläutert. Au&szlig;erdem können die Operationen Schl&uuml;sselgenerierung, Signieren sowie Verifizieren durchgef&uuml;hrt werden.</p>
	 
	<h2>Reiter 1: Schlüsselerzeugung</h2>
	<p>Der 1. Reiter zeigt die Bestandteile der verwendeten Schlüssel: den Seed, die verwendeten Bitmasken und er gibt die Schl&uuml;ssel  (((  welche? Ich sehe nur einen Public-Key))) aus.</p>
	<p>Des weiteren werden noch Informationen zur Schl&uuml;ssell&auml;nge ausgegeben.</p>
	 
	<p>Außerdem werden die Bitmasken eingefärbt. Da der Public-Key standardisiert ((( Was ist mit "standardisiert" gemeint? ))) ausgegeben wird, stimmt der farblich markierte Wert nicht mit dem im Feld "Bitmasken" überein. Semantisch sind sie aber dasselbe. ((( Wie kann ich das nachprüfen? ))) </p> 
	 
	<p>Die folgenden Reiter 2 und 3 funktionieren erst, wenn in Reiter 1 bereits Schlüssel erzeugt worden sind.</p>
	<br />

	 
	<h2>Reiter 2: Signatur und Verifikation</h2>
	 
	<p>Der 2. Reiter bietet die M&ouml;glichkeit, eine Nachricht zu signieren und zu verifizieren.</p>
	 
	<p>Mit den folgenden 3 Buttons können verschiedene Teile der Signatur hervorgehoben werden:</p>
	 
	<ul>
		<li>Der Button <b>Authentifizierungspfad</b> färbt den verwendeten Weg durch den ((( Welchen Baum? Den Gesamtbaum? ))) Baum ein. Ein Authentifizierungspfad gibt an, welche Strukturen ((( Kann man "Strukturen" nicht genauer bezeichnen? ))) für die Signatur verwendet wurden.</li>
		<li>Der Button <b>Aktuelles Blatt</b> hebt das in der Signatur enthaltene HORST-Blatt hervor.</li>
		<li>Der Button <b>Signatur</b> zeigt die HORST-Signatur ((( Ist die HORST-Signatur die eigentliche SPHINCS-Signatur? Wenn ja würde ich nur von der "Signatur" sprechen.))) im Signatur-Feld an.</li>
	</ul>
	<br />

	 
	<h2>Reiter 3: SPHINCS-Übersicht</h2>
	
	<p>Der 3. Reiter zeigt einen Ausschnitt eines HyperTrees und gibt Informationen &uuml;ber die Struktur in SPHINCS. Weiters k&ouml;nnen die Daten für jedes einzelne Blatt eingesehen werden, indem man auf das Blatt klickt.((( Ich bekam bei einem Klick keine Infos, die über den Balloontext hinausgehen. ))) </p>

	<p>Die einzelnen Ebenen der Struktur sind farblich gekennzeichnet so, dass man sieht, welches Blatt, welcher Ebene angeh&ouml;hrt.</p>
	<br />


	 
	<h1>Weitere Informationen</h1>
	
	<p>Weitere Informationen finden Sie auf der offiziellen Webseite des <a href="https://sphincs.cr.yp.to/">SPHINCS-Verfahrens</a>.</p>
	
	<p>Diese Webseite enthält diverse Papers und Pr&auml;sentationen zum Thema SPHINCS. Eine Referenzimplementierung steht ebenfalls zum Download zur Verfügung.</p>
	
	<p>[1] <a href="https://cryptojedi.org/papers/sphincs-20141001.pdf">SPHINCS: practical stateless hash-based signatures</a> by Daniel J. Bernstein, Daira Hopwood, Andreas Hülsing, Tanja Lange, Ruben Niederhagen, Louiza Papachristodoulou, Peter Schwabe, and Zooko Wilcox O'Hearn (2014) ist das Originalpaper zum SPHINCS-Verfahren.</p>
	
	<p>[2] <a href="https://en.wikipedia.org/wiki/Hash-based_cryptography">Hash-based cryptography</a> by Wikipedia. Diese Wikipedia-Seite enthält einen allgemeinen Überblick über Hash-basierte Signaturen (HBS).</p>
	
	<p>[3] <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography">Post-quantum cryptography</a> by Wikipedia</p>
	
	<p> Weitere Plugins in JCrypTool mit Quantencomputer-sicheren Verfahren:</p>
	<ul>	
		<li><a href="PLUGINS_ROOT/org.jcryptool.visual.merkletree/$nl$/help/content/index.html">MerkleTree</a></li>
		<li><a href="PLUGINS_ROOT/org.jcryptool.visual.wots/$nl$/help/content/index.html">WOTS / WOTS+</a></li>
	</ul>
	<br />
	
	
</body>
