#Eclipse modern messages class	
Tab0_Head0=eXtended Merkle MultiTree signature scheme
Tab0_Key_Button=Generate XMSS^MT key pair
MerkleTree_Generation_Info=Please create a XMSS^MT key pair before proceeding.
Tab0_MessageBox0=You have successfully created a XMSS^MT key pair.
Tab0_Txt0=The eXtended Merkle MultiTree signature scheme (XMSS^MT) is based on multiple XMSS trees chained together. The advantage compared to a simple XMSS tree which has the same size, is the reduced computation effort to create the key pair. The single trees are connected, by signing the XMSS root node of a lower layer. The lowest layer eventually is used to sign messages. If you are not familiar with XMSS, it is recommended to inform yourself about it first. You can also find it in this visualization.
Tab0_Txt1=The 'Winternitz one-time signature' (In the WOTS+ variant) is used as one-time signature in XMSS^MT. Part of this algorithm is the Winternitz parameter w. It determines the signature length. A larger value leads to shorter signatures but increased computation efforts. It does not affect the scheme's security. Although it can be arbitrarily big, it is common practice to use 4 or 16. You will find more information about WOTS+ in the help menu.
Tab0_Txt2=In this scheme multiple single trees with the same height come to use. Here you can set the properties of the single trees and the corresponding amount of one-time signatures. In the process of key generation, the WOTS keypairs and the MultiTree, consisting of normal XMSS trees, is generated.
Tab0_Txt3=Single tree height

Tab1_Head0=MultiTree XMSS
Tab1_Txt0=This graph depicts a MultiTree. The MultiTree resembles a XMSS tree. The single trees are arranged on layers and each one is highlighted with color. Trees of higher layers sign the root nodes of lower levels, linking the single trees together this way. Trees of lower levels can be generated independently from each other. This saves time at the key generation process, as only those trees have to be generated, which are needed. As additional advantage proves, that single trees within a MultiTree do not require to have the same hash function. If a currently used hash function turns out to be unsafe, the next generated single tree can use a different one, increasing the security again. The compatibility to an old key is ensured, as the length of a hash is not important to the layer above, which signs the single tree. The signature differs lightly, as it consists of multiple XMSS signatures. You will find more information in the \u201CSignature generation\u201C/\u201CVerification\u201C tabs.\r\n\r\nYou can select leafs or nodes to see their hash values, as well as highlight the path to the root node and their authentication nodes.\r\nLegend:\r\nblinking black - path to the root node. blinking red - nodes of the  authentication path.
Tab1_Txt1=Choose a node to see the hashvalue of it.
Tab1_Node=Leaf/Root

MerkleTreeVerify_0=The signature which was created in the \u201CSignature generation\u201C tab, can now be verified. Initially, the leaf with the correct index (black blinking path) is selected. If you choose another leaf with the wrong index, the verification will fail. The basic verification process does not differ from an XMSS signature, as we start with a single tree, which is equivalent to an XMSS tree.\r\n\r\nThe following information is needed for the first step of verification.\r\n\u2022Index and seed of the MultiTree signature\r\n\u2022The reduced XMSS signatures (containing one-time signature, and the authentication path)\r\n\u2022The message\r\nDuring the verification of a message the one-time public key is calculated from the message and the one-time signature. This key is used to calculate the corresponding leaf of the L-Tree. Together with the index and the authentication path, a root node public key is calculated. Now, instead of comparing this result with the published XMSS public key, we step up to the next layer of single trees. As this root value, we just calculated, was signed by the single tree a layer above. So we calculate this signature the same way. Of course we use the root value instead of the message this time. Depending on the number of single trees, we will eventually come the the tree's top layer and recieve a single root node value. This root node public key can be checked against the published XMSS^MT public key. If they are the same, all signatures in the chain were correct and the XMSS^MT signature is accepted, otherwise the verification fails. 
MerkleTreeKeyTab_0=In this tab you can take a look at the XMSS^MT key pair.\n\u2022The public key consists of the value of the root node and the public seed.\n\u2022The private key consists of an index of the next one-time key pair which will be used, the public and private seed, and all private one-time keys.


